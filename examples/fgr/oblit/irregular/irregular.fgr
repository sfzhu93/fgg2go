package main;
type HasRep interface { getRep() Rep };
type Any interface { HasRep };
type Bool interface { HasRep; Not() HasRep };
type TT struct { };
func (x0 TT) getRep() Rep { return TT[[]] };
type FF struct { };
func (x0 FF) getRep() Rep { return FF[[]] };
func (this TT) Not() HasRep { return FF{} };
func (this FF) Not() HasRep { return TT{} };
type Nat interface { HasRep; Add(n HasRep) HasRep };
type Zero struct { };
func (x0 Zero) getRep() Rep { return Zero[[]] };
type Succ struct { pred Nat };
func (x0 Succ) getRep() Rep { return Succ[[]] };
func (m Zero) Add(n HasRep) HasRep { return n.(Nat) };
func (m Succ) Add(n HasRep) HasRep { return Succ{m.pred.(Nat).Add(n.(Nat)).(Nat)} };
type Func interface { HasRep; Apply(x HasRep) HasRep };
type incr struct { n Nat };
func (x0 incr) getRep() Rep { return incr[[]] };
func (this incr) Apply(x HasRep) HasRep { return x.(Nat).Add(this.n.(Nat)).(Nat) };
type not struct { };
func (x0 not) getRep() Rep { return not[[]] };
func (this not) Apply(x HasRep) HasRep { return x.(Bool).Not().(Bool) };
type Pair struct { a Rep; fst Any; snd Any };
func (x0 Pair) getRep() Rep { return Pair[[x0.a]] };
type pairMap struct { a Rep; f Func };
func (x0 pairMap) getRep() Rep { return pairMap[[x0.a]] };
func (p pairMap) Apply(x HasRep) HasRep { return Pair{p.a, p.f.(Func).Apply(x.(Pair).fst.(Any)).(Any), p.f.(Func).Apply(x.(Pair).snd.(Any)).(Any)} };
type Balanced interface { HasRep; BalancedMap(f HasRep) HasRep };
type Leaf struct { a Rep };
func (x0 Leaf) getRep() Rep { return Leaf[[x0.a]] };
type Node struct { a Rep; label Any; children Balanced };
func (x0 Node) getRep() Rep { return Node[[x0.a]] };
func (leaf Leaf) BalancedMap(f HasRep) HasRep { return Leaf{leaf.a} };
func (node Node) BalancedMap(f HasRep) HasRep { return Node{node.a, f.(Func).Apply(node.label.(Any)).(Any), node.children.(Balanced).BalancedMap(pairMap{node.a, f.(Func)}).(Balanced)} };
type D struct { };
func (x0 D) getRep() Rep { return D[[]] };
func (d D) _0() HasRep { return Zero{} };
func (d D) _1() HasRep { return Succ{D{}._0().(Nat)} };
func (d D) _2() HasRep { return Succ{D{}._1().(Nat)} };
func (d D) _3() HasRep { return Succ{D{}._2().(Nat)} };
func (d D) _4() HasRep { return Succ{D{}._3().(Nat)} };
func (d D) _5() HasRep { return Succ{D{}._4().(Nat)} };
func (d D) _6() HasRep { return Succ{D{}._5().(Nat)} };
func (d D) _7() HasRep { return Succ{D{}._6().(Nat)} };
func main() { _ = Node{Nat[[]], D{}._1().(Nat), Node{Pair[[Nat[[]]]], Pair{Nat[[]], D{}._2().(Nat), D{}._3().(Nat)}, Node{Pair[[Pair[[Nat[[]]]]]], Pair{Pair[[Nat[[]]]], Pair{Nat[[]], D{}._4().(Nat), D{}._5().(Nat)}, Pair{Nat[[]], D{}._6().(Nat), D{}._7().(Nat)}}, Leaf{Pair[[Pair[[Pair[[Nat[[]]]]]]]]}}}}.BalancedMap(incr{D{}._1().(Nat)}).(Balanced) }