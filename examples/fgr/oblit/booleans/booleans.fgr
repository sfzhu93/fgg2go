package main;
type HasRep interface { getRep() Rep };
type Any interface { HasRep };
type Eq interface { HasRep; Equal(that HasRep) HasRep };
type Bool interface { HasRep; Not() HasRep; Equal(that HasRep) HasRep; Cond(a Rep, br HasRep) HasRep };
type Branches interface { HasRep; IfTT() HasRep; IfFF() HasRep };
type TT struct { };
func (x0 TT) getRep() Rep { return TT[[]] };
type FF struct { };
func (x0 FF) getRep() Rep { return FF[[]] };
func (this TT) Not() HasRep { return FF{} };
func (this FF) Not() HasRep { return TT{} };
func (this TT) Equal(that HasRep) HasRep { return that.(Bool) };
func (this FF) Equal(that HasRep) HasRep { return that.(Bool).Not().(Bool) };
func (this TT) Cond(a Rep, br HasRep) HasRep { return br.(Branches).IfTT().(Any) };
func (this FF) Cond(a Rep, br HasRep) HasRep { return br.(Branches).IfFF().(Any) };
type exampleBr struct { x t; y t };
func (x0 exampleBr) getRep() Rep { return exampleBr[[]] };
func (this exampleBr) IfTT() HasRep { return this.x.m(this.y).(t) };
func (this exampleBr) IfFF() HasRep { return this.x };
type t struct { };
func (x0 t) getRep() Rep { return t[[]] };
func (x0 t) m(x1 HasRep) HasRep { return x1.(t) };
type Ex struct { };
func (x0 Ex) getRep() Rep { return Ex[[]] };
func (d Ex) example(b HasRep, x HasRep, y HasRep) HasRep { return b.(Bool).Cond(t[[]], exampleBr{x.(t), y.(t)}).(t).m(t{}).(t) };
func main() { _ = Ex{}.example(TT{}, t{}, t{}).(t) }