package main;
type HasRep interface { getRep() Rep };
type Any interface { HasRep };
type Bool interface { HasRep; Not() HasRep };
type TT struct { };
func (x0 TT) getRep() Rep { return TT[[]] };
type FF struct { };
func (x0 FF) getRep() Rep { return FF[[]] };
func (this TT) Not() HasRep { return FF{} };
func (this FF) Not() HasRep { return TT{} };
type Nat interface { HasRep; Add(n HasRep) HasRep };
type Zero struct { };
func (x0 Zero) getRep() Rep { return Zero[[]] };
type Succ struct { pred Nat };
func (x0 Succ) getRep() Rep { return Succ[[]] };
func (m Zero) Add(n HasRep) HasRep { return n.(Nat) };
func (m Succ) Add(n HasRep) HasRep { return Succ{m.pred.(Nat).Add(n.(Nat)).(Nat)} };
type Func interface { HasRep; Apply(x HasRep) HasRep };
type incr struct { n Nat };
func (x0 incr) getRep() Rep { return incr[[]] };
func (this incr) Apply(x HasRep) HasRep { return x.(Nat).Add(this.n.(Nat)).(Nat) };
type not struct { };
func (x0 not) getRep() Rep { return not[[]] };
func (this not) Apply(x HasRep) HasRep { return x.(Bool).Not().(Bool) };
type List interface { HasRep; Map(b Rep, f HasRep) HasRep };
type Nil struct { a Rep };
func (x0 Nil) getRep() Rep { return Nil[[x0.a]] };
type Cons struct { a Rep; head Any; tail List };
func (x0 Cons) getRep() Rep { return Cons[[x0.a]] };
func (xs Nil) Map(b Rep, f HasRep) HasRep { return Nil{b} };
func (xs Cons) Map(b Rep, f HasRep) HasRep { return Cons{b, f.(Func).Apply(xs.head.(Any)).(Any), xs.tail.(List).Map(b, f.(Func)).(List)} };
type Pair struct { a Rep; b Rep; Fst Any; Snd Any };
func (x0 Pair) getRep() Rep { return Pair[[x0.a, x0.b]] };
type D struct { };
func (x0 D) getRep() Rep { return D[[]] };
func (d D) _1() HasRep { return Succ{Zero{}} };
func (d D) _2() HasRep { return Succ{D{}._1().(Nat)} };
func (d D) _3() HasRep { return Succ{D{}._2().(Nat)} };
func main() { _ = Pair{List[[Bool[[]]]], List[[Nat[[]]]], Cons{Bool[[]], TT{}, Cons{Bool[[]], FF{}, Nil{Bool[[]]}}}.Map(Bool[[]], not{}).(List), Cons{Nat[[]], D{}._1().(Nat), Cons{Nat[[]], D{}._2().(Nat), Cons{Nat[[]], D{}._3().(Nat), Nil{Nat[[]]}}}}.Map(Nat[[]], incr{D{}._1().(Nat)}).(List)} }