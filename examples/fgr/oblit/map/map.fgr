package main;
type HasRep interface { getRep() Rep };
type Any interface { HasRep };
type ToAny struct { any Any };
func (x0 ToAny) getRep() Rep { return ToAny[[]] };
type Eq interface { HasRep; Equal(that HasRep) HasRep };
type Bool interface { HasRep; Not() HasRep; Equal(that HasRep) HasRep; Cond(a Rep, br HasRep) HasRep };
type Branches interface { HasRep; IfTT() HasRep; IfFF() HasRep };
type TT struct { };
func (x0 TT) getRep() Rep { return TT[[]] };
type FF struct { };
func (x0 FF) getRep() Rep { return FF[[]] };
func (this TT) Not() HasRep { return FF{} };
func (this FF) Not() HasRep { return TT{} };
func (this TT) Equal(that HasRep) HasRep { return that.(Bool) };
func (this FF) Equal(that HasRep) HasRep { return that.(Bool).Not().(Bool) };
func (this TT) Cond(a Rep, br HasRep) HasRep { return br.(Branches).IfTT().(Any) };
func (this FF) Cond(a Rep, br HasRep) HasRep { return br.(Branches).IfFF().(Any) };
type Func interface { HasRep; Apply(x HasRep) HasRep };
type not struct { };
func (x0 not) getRep() Rep { return not[[]] };
func (this not) Apply(x HasRep) HasRep { return x.(Bool).Not().(Bool) };
type compose struct { a Rep; b Rep; c Rep; f Func; g Func };
func (x0 compose) getRep() Rep { return compose[[x0.a, x0.b, x0.c]] };
func (this compose) Apply(x HasRep) HasRep { return this.g.(Func).Apply(this.f.(Func).Apply(x.(Any)).(Any)).(Any) };
type List interface { HasRep; Map(b Rep, f HasRep) HasRep; Member(x HasRep) HasRep };
type Nil struct { a Rep };
func (x0 Nil) getRep() Rep { return Nil[[x0.a]] };
type Cons struct { a Rep; head Eq; tail List };
func (x0 Cons) getRep() Rep { return Cons[[x0.a]] };
func (xs Nil) Map(b Rep, f HasRep) HasRep { return Nil{b} };
func (xs Cons) Map(b Rep, f HasRep) HasRep { return Cons{b, f.(Func).Apply(xs.head.(Eq)).(Eq), xs.tail.(List).Map(b, f.(Func)).(List)} };
type memberBr struct { b Rep; xs List; x Eq };
func (x0 memberBr) getRep() Rep { return memberBr[[x0.b]] };
func (this memberBr) IfTT() HasRep { return TT{} };
func (this memberBr) IfFF() HasRep { return this.xs.(List).Member(this.x.(Eq)).(Bool) };
func (xs Nil) Member(x HasRep) HasRep { return FF{} };
func (xs Cons) Member(x HasRep) HasRep { return x.(Eq).Equal(xs.head.(Eq)).(Bool).Cond(Bool[[]], memberBr{xs.a, xs, x.(Eq)}).(Bool) };
func main() { _ = (if Cons{Bool[[]], TT{}, Cons{Bool[[]], FF{}, Nil{Bool[[]]}}}.Map(Bool[[]], not{}).(List).getRep() << Cons[[Bool[[]]]] then Cons{Bool[[]], TT{}, Cons{Bool[[]], FF{}, Nil{Bool[[]]}}}.Map(Bool[[]], not{}).(List).(Cons) else panic).head.(Bool).Not().(Bool) }