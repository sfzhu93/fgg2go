package main;
type HasRep interface { getRep() Rep };
type Any interface { HasRep };
type ToAny struct { any Any };
func (x0 ToAny) getRep() Rep { return ToAny[[]] };
type Eq interface { HasRep; Equal(that HasRep) HasRep };
type Bool interface { HasRep; Not() HasRep; Equal(that HasRep) HasRep; Cond(a Rep, br HasRep) HasRep };
type Branches interface { HasRep; IfTT() HasRep; IfFF() HasRep };
type TT struct { };
func (x0 TT) getRep() Rep { return TT[[]] };
type FF struct { };
func (x0 FF) getRep() Rep { return FF[[]] };
func (this TT) Not() HasRep { return FF{} };
func (this FF) Not() HasRep { return TT{} };
func (this TT) Equal(that HasRep) HasRep { return that.(Bool) };
func (this FF) Equal(that HasRep) HasRep { return that.(Bool).Not().(Bool) };
func (this TT) Cond(a Rep, br HasRep) HasRep { return br.(Branches).IfTT().(Any) };
func (this FF) Cond(a Rep, br HasRep) HasRep { return br.(Branches).IfFF().(Any) };
type Nat interface { HasRep; Add(n HasRep) HasRep; Equal(n HasRep) HasRep; equalZero() HasRep; equalSucc(m HasRep) HasRep };
type Zero struct { };
func (x0 Zero) getRep() Rep { return Zero[[]] };
type Succ struct { pred Nat };
func (x0 Succ) getRep() Rep { return Succ[[]] };
func (m Zero) Add(n HasRep) HasRep { return n.(Nat) };
func (m Succ) Add(n HasRep) HasRep { return Succ{m.pred.(Nat).Add(n.(Nat)).(Nat)} };
func (m Zero) Equal(n HasRep) HasRep { return n.(Nat).equalZero().(Bool) };
func (m Succ) Equal(n HasRep) HasRep { return n.(Nat).equalSucc(m.pred.(Nat)).(Bool) };
func (n Zero) equalZero() HasRep { return TT{} };
func (n Succ) equalZero() HasRep { return FF{} };
func (n Zero) equalSucc(m HasRep) HasRep { return FF{} };
func (n Succ) equalSucc(m HasRep) HasRep { return m.(Nat).Equal(n.pred.(Nat)).(Bool) };
type Func interface { HasRep; Apply(x HasRep) HasRep };
type incr struct { n Nat };
func (x0 incr) getRep() Rep { return incr[[]] };
func (this incr) Apply(x HasRep) HasRep { return x.(Nat).Add(this.n.(Nat)).(Nat) };
type not struct { };
func (x0 not) getRep() Rep { return not[[]] };
func (this not) Apply(x HasRep) HasRep { return x.(Bool).Not().(Bool) };
type compose struct { a Rep; b Rep; c Rep; f Func; g Func };
func (x0 compose) getRep() Rep { return compose[[x0.a, x0.b, x0.c]] };
func (this compose) Apply(x HasRep) HasRep { return this.g.(Func).Apply(this.f.(Func).Apply(x.(Any)).(Any)).(Any) };
type List interface { HasRep; Map(b Rep, f HasRep) HasRep; Member(x HasRep) HasRep };
type Nil struct { a Rep };
func (x0 Nil) getRep() Rep { return Nil[[x0.a]] };
type Cons struct { a Rep; head Eq; tail List };
func (x0 Cons) getRep() Rep { return Cons[[x0.a]] };
func (xs Nil) Map(b Rep, f HasRep) HasRep { return Nil{b} };
func (xs Cons) Map(b Rep, f HasRep) HasRep { return Cons{b, f.(Func).Apply(xs.head.(Eq)).(Eq), xs.tail.(List).Map(b, f.(Func)).(List)} };
type memberBr struct { b Rep; xs List; x Eq };
func (x0 memberBr) getRep() Rep { return memberBr[[x0.b]] };
func (this memberBr) IfTT() HasRep { return TT{} };
func (this memberBr) IfFF() HasRep { return this.xs.(List).Member(this.x.(Eq)).(Bool) };
func (xs Nil) Member(x HasRep) HasRep { return FF{} };
func (xs Cons) Member(x HasRep) HasRep { return x.(Eq).Equal(xs.head.(Eq)).(Bool).Cond(Bool[[]], memberBr{xs.a, xs, x.(Eq)}).(Bool) };
type D struct { };
func (x0 D) getRep() Rep { return D[[]] };
func (d D) _1() HasRep { return Succ{Zero{}} };
func (d D) _2() HasRep { return D{}._1().(Nat).Add(D{}._1().(Nat)).(Nat) };
func (d D) _3() HasRep { return D{}._2().(Nat).Add(D{}._1().(Nat)).(Nat) };
func main() { _ = compose{Nat[[]], Nat[[]], Nat[[]], incr{D{}._1().(Nat)}, incr{D{}._2().(Nat)}}.Apply(D{}._3().(Nat)).(Nat).Add(Zero{}).(Nat) }